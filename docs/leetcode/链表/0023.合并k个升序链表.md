# 0023. 合并k个升序链表

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

 

## 示例 1：

输入：`lists = [[1,4,5],[1,3,4],[2,6]]`
输出：`[1,1,2,3,4,4,5,6]`
解释：链表数组如下：
```c
[
  1->4->5,
  1->3->4,
  2->6
]
```

将它们合并到一个有序链表中得到`1->1->2->3->4->4->5->6`

## 示例 2：

输入：`lists = []`

输出：`[]`

## 示例 3：

输入：`lists = [[]]`

输出：`[]`
 
## 提示：

- k == lists.length
- 0 <= k <= $10^4$
- 0 <= lists[i].length <= 500
- $-10^4$ <= lists[i][j] <= 10^4
- lists[i] 按**升序**排列
- lists[i].length 的总和不超过 $10^4$

## 思路

我们可以使用分治的思想来合并k个升序链表。具体步骤如下：

1. 首先定义一个辅助函数`mergeTwoLists`，用于合并两个有序链表。该函数的实现可以参考这道题[0021. 合并两个有序链表](0021.合并两个有序链表.md)。
2. 然后定义一个递归函数`divide`，用于将链表数组划分为两部分，并递归地合并每一部分。具体来说，`divide`函数接受链表数组和左右边界作为参数，如果左右边界相等，则返回对应的链表；否则，计算中间位置，将链表数组划分为左半部分和右半部分，递归地调用`divide`函数合并这两部分，最后使用`mergeTwoLists`函数将合并后的两部分链表合并起来。
3. 最后，在主函数`mergeKLists`中，首先检查链表数组是否为空或只有一个链表，如果是，则直接返回对应的链表；否则，调用`divide`函数进行合并，并返回最终的合并结果。


## 解答

=== "C++"
```cpp
class Solution {
private:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        if(list1 == NULL) return list2;
        if(list2 == NULL) return list1;

        if(list1->val <= list2->val){
            list1->next = mergeTwoLists(list1->next,list2);
            return list1;
        }else{
            list2->next = mergeTwoLists(list1,list2->next);
            return list2;
        }
    }

    ListNode* divide(vector<ListNode*>& lists,int left,int right){
        if(left  == right)  return lists[left];

        int mid = left + (right - left)/2;

        ListNode* lpart = divide(lists,left,mid);
        ListNode* rpart = divide(lists,mid+1,right);

        return mergeTwoLists(lpart,rpart);
    }
public:
    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.empty())  return NULL;
        if(lists.size()==1)  return lists[0];
        return divide(lists,0,lists.size()-1);

    }
};
```